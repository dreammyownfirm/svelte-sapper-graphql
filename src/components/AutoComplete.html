<div class="{inputClass}">
	<span ref:ACSelectedTags/>
	<input ref:ACInput 
		type="text" class="w3-border-0" placeholder="Type a letter or space"
		on:input="input(event)"
		on:keydown="keydown(event)"
		>
</div>
<div class="popup" style="margin-right:{$isMobile ? '16px' : '32px'}">
	<div ref:ACTags class="w3-container w3-card-4 w3-white"/>
</div>

<style>
	input {
		outline: none;
	}

	.popup {
		position: absolute;
		margin-top: -16px;
		z-index: 10;
	}
</style>

<script>
	export default {
		data() {
			return {
				inputField: {},
				tagsList: {},
				currentFocus: 0
			}
		},

		oncreate() {
			// initiate the autocomplete function on the "myInput" element, and pass along the countries array as possible autocomplete values
			console.log('AC/oncreate', this.get())
			// autocomplete(this.refs.ACInput, this.refs.ACSelectedTags, this.refs.ACTagsList, this.get().data)
		},

		methods: {

			input(evt) {
				console.log('AC/input')
				let val = this.refs.ACInput.value
				let upperCaseList, filteredList

				// close any already open lists of autocompleted value
				this.closeTagsList()
				if( !val ) {
					return false
				}

				if( val.length == 1 && evt.key === ' ') { 
					// SPACE key pressed in first position, return all tags
					filteredList = this.get().data
				} else {
					// remove spaces
					val = val.trim()
					// KeepÂ only the matching tags
					filteredList = this.get().data.filter( ({name}) => name.substr(0, val.length).toUpperCase() === val.toUpperCase())
				}

				if( filteredList.length === 0 ) {
					// list is empty, no need to display popup container
					return
				}

				this.currentFocus = 0

				// built the tags container
				let a = document.createElement("div")
				a.setAttribute("class", "autocomplete-taglist w3-margin-bottom")
				this.refs.ACTags.appendChild(a)

				filteredList.map( ({code, name}) => {
					// check if the item starts with the same letters as the text field value
						// create a DIV element for each matching element
						let b = document.createElement("span")
						b.setAttribute('class', 'autocomplete-tag w3-tag w3-margin-right w3-margin-top w3-round w3-blue w3-center')
						// make the matching letters bold
						b.innerHTML = `<strong>${name.substr(0, val.length)}</strong>`
						b.innerHTML += name.substr(val.length)

						// execute a function when someone clicks on the item value (DIV element)
						b.addEventListener("click", e => {
							// insert the value for the autocomplete text field
							this.refs.ACInput.value = ''
							this.refs.ACSelectedTags.innerHTML += `<span class="w3-tag w3-margin-right w3-round w3-blue w3-center" value="${e.target.innerText}">${e.target.innerText}&nbsp;<i onclick="this.parentNode.parentNode.removeChild(this.parentNode)" class="fas fa-times-circle" /></span>`
							// close the list of autocompleted values, or any other open lists of autocompleted values
							this.closeTagsList()
						})
						a.appendChild(b)
				})
				
				// make the first of the tags list active by default
				this.addActive(this.refs.ACTags.getElementsByClassName('autocomplete-tag'))
			},

			keydown(evt) {
				let tagsContainer = Array.from(this.refs.ACTags.getElementsByClassName('autocomplete-taglist'))[0]
				let tagsContainerLines = tagsContainer ? tagsContainer.clientHeight/40 : 1
				let tags = this.refs.ACTags.getElementsByClassName('autocomplete-tag')
				console.log('AC/keydown key', evt.key, tagsContainerLines)
				switch (evt.key) {
					case 'Backspace' :
						if( evt.target.value.length == 0) {
							evt.preventDefault()
							this.closeTagsList()
						}
						break

					case 'Escape': 
						evt.preventDefault()
						this.closeTagsList()
						break

					case 'ArrowRight': 
						evt.preventDefault()
						this.currentFocus++
						this.addActive(tags)
						break

					case 'ArrowLeft': 
						evt.preventDefault()
						this.currentFocus--
						this.addActive(tags)
						break

					case 'ArrowDown': 
						evt.preventDefault()
						this.currentFocus += Math.round(tags.length/tagsContainerLines)-1
						this.addActive(tags)
						break

					case 'ArrowUp': 
						evt.preventDefault()
						this.currentFocus -= Math.round(tags.length/tagsContainerLines)-1
						this.addActive(tags)
						break

					case 'Home':
						evt.preventDefault()
						this.currentFocus = 0
						this.addActive(tags)
						break

					case 'End':
						evt.preventDefault()
						this.currentFocus = tags.length-1
						this.addActive(tags)
						break

					case 'Tab': 
					case 'Enter': 
						evt.preventDefault()
						if (this.currentFocus > -1) {
							// simulate a click on the "active" item
							tags && tags[this.currentFocus] && tags[this.currentFocus].click()
						}
						break
				}
			},

			addActive(tags) {
				// a function to classify an item as "active"
				if (!tags) {
					return false
				}

				// convert the HTMLcollection to array to remove the "active" class on all tags
				Array.from(tags).map(tag => tag.classList.remove('w3-green'))

				if (this.currentFocus >= tags.length) {
					this.currentFocus = 0
				}

				if (this.currentFocus < 0) {
					this.currentFocus = (tags.length - 1)
				}

				if (!tags[this.currentFocus]) {
					return false
				}

				// add class "autocomplete-active" to the active tag
				tags[this.currentFocus].classList.add('w3-green')
			},

			closeTagsList() {
				// close all autocomplete lists in the document, except the one passed as an argument
				while (this.refs.ACTags.hasChildNodes()) {   
					this.refs.ACTags.removeChild(this.refs.ACTags.firstChild)
				}
			}

		}
	}
</script>